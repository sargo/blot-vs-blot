// Generated by CoffeeScript 1.7.1
(function() {
  var EMPTY, KaluzaGame, PLAYER_A, PLAYER_B, game, shuffle,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  PLAYER_A = 1;

  PLAYER_B = 2;

  EMPTY = 0;

  shuffle = function(a) {
    var i, j, _i, _ref, _ref1;
    for (i = _i = _ref = a.length - 1; _ref <= 1 ? _i <= 1 : _i >= 1; i = _ref <= 1 ? ++_i : --_i) {
      j = Math.floor(Math.random() * (i + 1));
      _ref1 = [a[j], a[i]], a[i] = _ref1[0], a[j] = _ref1[1];
    }
    return a;
  };

  KaluzaGame = (function() {
    KaluzaGame.prototype.size = 0;

    KaluzaGame.prototype.map = [];

    KaluzaGame.prototype.state = [];

    KaluzaGame.prototype.fgColors = {
      0: 'rgb(240, 240, 240)',
      1: 'rgb(137, 188, 255)',
      2: 'rgb(235, 93, 70)'
    };

    KaluzaGame.prototype.bgColors = {
      0: 'rgb(210, 210, 210)',
      1: 'rgb(204, 226, 255)',
      2: 'rgb(235, 154, 141)'
    };

    KaluzaGame.prototype.hoverColors = {
      1: 'rgb(166, 204, 255)',
      2: 'rgb(235, 124, 106)'
    };

    KaluzaGame.prototype.hover = {
      1: null,
      2: null
    };

    KaluzaGame.prototype.active_player = PLAYER_A;

    function KaluzaGame(size) {
      this.size = size != null ? size : 9;
      this.finishTurn = __bind(this.finishTurn, this);
      this.createMap(this.size);
      this.createCanvas();
      this.refresh();
    }

    KaluzaGame.prototype.createMap = function() {
      var value, x, y, _i, _ref;
      for (x = _i = 0, _ref = this.size - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; x = 0 <= _ref ? ++_i : --_i) {
        this.state.push((function() {
          var _j, _ref1, _results;
          _results = [];
          for (y = _j = 0, _ref1 = this.size - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; y = 0 <= _ref1 ? ++_j : --_j) {
            _results.push(0);
          }
          return _results;
        }).call(this));
        value = function(a, b, size) {
          if (a + b < size) {
            return (a + b) * 100 + 100;
          } else {
            return (2 * (size - 1) - a - b) * 100 + 100;
          }
        };
        this.map.push((function() {
          var _j, _ref1, _results;
          _results = [];
          for (y = _j = 0, _ref1 = this.size - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; y = 0 <= _ref1 ? ++_j : --_j) {
            _results.push(value(x, y, this.size));
          }
          return _results;
        }).call(this));
      }
      this.state[0][0] = PLAYER_A;
      return this.state[this.size - 1][this.size - 1] = PLAYER_B;
    };

    KaluzaGame.prototype.refresh = function() {
      this.resizeCanvas();
      this.createDrawingContext();
      return this.draw();
    };

    KaluzaGame.prototype.createCanvas = function() {
      this.canvas = document.createElement('canvas');
      return document.getElementById('wrap').appendChild(this.canvas);
    };

    KaluzaGame.prototype.resizeCanvas = function() {
      this.cavnasSize = Math.min(window.innerHeight, window.innerWidth) - 20;
      this.canvas.height = this.cavnasSize;
      return this.canvas.width = this.cavnasSize;
    };

    KaluzaGame.prototype.createDrawingContext = function() {
      return this.drawingContext = this.canvas.getContext('2d');
    };

    KaluzaGame.prototype.getCenter = function(x, y) {
      var centerX, centerY, unit;
      unit = Math.round(this.cavnasSize / (this.size * 2 + 2));
      centerX = 2 * unit + x * 2 * unit;
      centerY = 2 * unit + y * 2 * unit;
      return [centerX, centerY];
    };

    KaluzaGame.prototype.drawCircle = function(centerX, centerY, radius, color) {
      this.drawingContext.beginPath();
      this.drawingContext.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);
      this.drawingContext.closePath();
      this.drawingContext.fillStyle = color;
      return this.drawingContext.fill();
    };

    KaluzaGame.prototype.drawText = function(centerX, centerY, size, color, text) {
      this.drawingContext.font = size + 'pt Tahoma';
      this.drawingContext.textAlign = 'center';
      this.drawingContext.textBaseline = 'top';
      this.drawingContext.fillStyle = color;
      return this.drawingContext.fillText(text, centerX, centerY - size);
    };

    KaluzaGame.prototype.getHoverPlayer = function(x, y) {
      var hoverX, hoverY, player, _i, _len, _ref, _ref1;
      _ref = [PLAYER_A, PLAYER_B];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        player = _ref[_i];
        if (this.hover[player] != null) {
          _ref1 = this.hover[player], hoverX = _ref1[0], hoverY = _ref1[1];
          if (x === hoverX && y === hoverY) {
            return player;
          }
        }
      }
      return null;
    };

    KaluzaGame.prototype.drawField = function(x, y) {
      var bgColor, centerX, centerY, fgColor, hover, obtainable, player, unit, _ref;
      player = this.state[x][y];
      unit = Math.round(this.cavnasSize / (this.size * 2 + 2));
      _ref = this.getCenter(x, y), centerX = _ref[0], centerY = _ref[1];
      fgColor = this.fgColors[player];
      bgColor = player !== EMPTY ? this.bgColors[player] : null;
      hover = this.getHoverPlayer(x, y);
      obtainable = this.isObtainable(x, y, PLAYER_A);
      if ((hover === PLAYER_A && obtainable) || hover === PLAYER_B) {
        bgColor = this.hoverColors[hover];
      }
      if (player === EMPTY && obtainable) {
        fgColor = this.bgColors[player];
      }
      if (bgColor != null) {
        this.drawCircle(centerX, centerY, unit * 1.2, bgColor);
      }
      this.drawCircle(centerX, centerY, unit * 0.8, fgColor);
      return this.drawText(centerX, centerY, Math.round(unit / 2), 'white', this.map[x][y]);
    };

    KaluzaGame.prototype.draw = function() {
      var center, fontSize, stats, x, y, _i, _ref, _results;
      this.drawingContext.clearRect(0, 1, this.cavnasSize, this.cavnasSize);
      stats = this.getStats();
      center = Math.round(this.cavnasSize / 2);
      fontSize = Math.round(this.cavnasSize / 4);
      if (stats[PLAYER_B] === 0) {
        console.log('player A wins');
        this.drawText(center, center, fontSize, 'red', 'WIN');
        return this.active_player = EMPTY;
      } else if (stats[PLAYER_A] === 0) {
        console.log('player B wins');
        this.drawText(center, center, fontSize, 'red', 'LOSS');
        return this.active_player = EMPTY;
      } else {
        _results = [];
        for (x = _i = 0, _ref = this.size - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; x = 0 <= _ref ? ++_i : --_i) {
          _results.push((function() {
            var _j, _ref1, _results1;
            _results1 = [];
            for (y = _j = 0, _ref1 = this.size - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; y = 0 <= _ref1 ? ++_j : --_j) {
              _results1.push(this.drawField(x, y));
            }
            return _results1;
          }).call(this));
        }
        return _results;
      }
    };

    KaluzaGame.prototype.getStats = function() {
      var player, stats, x, y, _i, _j, _k, _len, _ref, _ref1, _ref2;
      stats = {
        1: 0,
        2: 0
      };
      for (x = _i = 0, _ref = this.size - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; x = 0 <= _ref ? ++_i : --_i) {
        for (y = _j = 0, _ref1 = this.size - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; y = 0 <= _ref1 ? ++_j : --_j) {
          _ref2 = [PLAYER_A, PLAYER_B];
          for (_k = 0, _len = _ref2.length; _k < _len; _k++) {
            player = _ref2[_k];
            if (this.state[x][y] === player) {
              stats[player] += this.map[x][y];
            }
          }
        }
      }
      return stats;
    };

    KaluzaGame.prototype.getMouseLocation = function(e) {
      var x, y;
      x = y = null;
      if (e.pageX !== void 0 && e.pageY !== void 0) {
        x = e.pageX;
        y = e.pageY;
      } else {
        x = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
        y = e.clientY + document.body.scrollTop + document.documentElement.scrollTop;
      }
      x -= this.canvas.offsetLeft;
      y -= this.canvas.offsetTop;
      x = Math.min(x, this.cavnasSize);
      y = Math.min(y, this.cavnasSize);
      return [x, y];
    };

    KaluzaGame.prototype.getDistance = function(x1, y1, x2, y2) {
      var xd, yd;
      xd = x2 - x1;
      yd = y2 - y1;
      return Math.sqrt(xd * xd + yd * yd);
    };

    KaluzaGame.prototype.getNearestField = function(mouseX, mouseY) {
      var centerX, centerY, distance, minDistance, nearest, x, y, _i, _j, _ref, _ref1, _ref2;
      minDistance = Infinity;
      nearest = null;
      for (x = _i = 0, _ref = this.size - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; x = 0 <= _ref ? ++_i : --_i) {
        for (y = _j = 0, _ref1 = this.size - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; y = 0 <= _ref1 ? ++_j : --_j) {
          _ref2 = this.getCenter(x, y), centerX = _ref2[0], centerY = _ref2[1];
          distance = this.getDistance(mouseX, mouseY, centerX, centerY);
          if (distance < minDistance) {
            minDistance = distance;
            nearest = [x, y];
          }
        }
      }
      return nearest;
    };

    KaluzaGame.prototype.onClick = function(e) {
      var clicked, mouseX, mouseY, x, y, _ref;
      if (this.active_player === PLAYER_A) {
        _ref = this.getMouseLocation(e), mouseX = _ref[0], mouseY = _ref[1];
        clicked = this.getNearestField(mouseX, mouseY);
        if (clicked != null) {
          x = clicked[0], y = clicked[1];
          if (this.clickField(x, y, PLAYER_A, PLAYER_B)) {
            this.hover[PLAYER_A] = null;
            this.draw();
            this.opponentTurn();
          }
        }
      }
      return false;
    };

    KaluzaGame.prototype.onMouseMove = function(e) {
      var mouseX, mouseY, nearest, _ref;
      if (this.active_player === PLAYER_A) {
        _ref = this.getMouseLocation(e), mouseX = _ref[0], mouseY = _ref[1];
        nearest = this.getNearestField(mouseX, mouseY);
        if ((nearest != null) && (this.getFieldId(nearest)) !== (this.getFieldId(this.hover[PLAYER_A]))) {
          this.hover[PLAYER_A] = nearest;
          this.draw();
        }
      }
      return false;
    };

    KaluzaGame.prototype.onMouseOut = function(e) {
      if (this.active_player === PLAYER_A) {
        this.hover[PLAYER_A] = null;
        this.draw();
      }
      return false;
    };

    KaluzaGame.prototype.clickField = function(x, y, player, opponent) {
      if (this.state[x][y] === player) {
        console.log("player " + player + " releases [" + x + ", " + y + "] field");
        return this.releaseField(x, y, player);
      } else if (this.isObtainable(x, y, player)) {
        if (this.state[x][y] === opponent) {
          console.log("player " + player + " will fight for [" + x + ", " + y + "] field");
          return this.fightForField(x, y, player, opponent);
        } else {
          console.log("player " + player + " obtains [" + x + ", " + y + "] field");
          return this.obtainField(x, y, player);
        }
      }
      return false;
    };

    KaluzaGame.prototype.releaseField = function(fieldX, fieldY, player) {
      var group, points, value, x, y, _i, _j, _len, _len1, _ref, _ref1;
      group = this.getGroup(fieldX, fieldY);
      if (group.length === 1) {
        console.log("can't release last field in group!");
        return false;
      }
      points = 0;
      for (_i = 0, _len = group.length; _i < _len; _i++) {
        _ref = group[_i], x = _ref[0], y = _ref[1];
        points += this.map[x][y];
      }
      value = Math.round(points / (group.length - 1));
      for (_j = 0, _len1 = group.length; _j < _len1; _j++) {
        _ref1 = group[_j], x = _ref1[0], y = _ref1[1];
        this.map[x][y] = value;
      }
      this.state[fieldX][fieldY] = EMPTY;
      this.map[fieldX][fieldY] = 0;
      return true;
    };

    KaluzaGame.prototype.fightForField = function(defenseX, defenseY, player, opponent) {
      var attackField, attackValue, attackX, attackY, defenseValue, maxGroup, nearX, nearY, x, y, _i, _len, _ref, _ref1, _ref2;
      _ref = [defenseX, defenseY], x = _ref[0], y = _ref[1];
      attackValue = 0;
      attackField = null;
      _ref1 = [[x - 1, y], [x + 1, y], [x, y - 1], [x, y + 1]];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        _ref2 = _ref1[_i], nearX = _ref2[0], nearY = _ref2[1];
        if (nearX >= 0 && nearX < this.size && nearY >= 0 && nearY < this.size) {
          if (this.state[nearX][nearY] === player && this.map[nearX][nearY] > attackValue) {
            attackValue = this.map[nearX][nearY];
            attackField = [nearX, nearY];
          }
        }
      }
      attackX = attackField[0], attackY = attackField[1];
      maxGroup = this.getGroup(attackX, attackY);
      defenseValue = this.map[defenseX][defenseY];
      if (attackValue > defenseValue) {
        console.log("player " + player + " won [" + x + ", " + y + "] field");
        this.map[attackX][attackY] = attackValue - defenseValue;
        this.map[defenseX][defenseY] = 0;
        this.obtainField(defenseX, defenseY, player);
      } else if (attackValue === defenseValue) {
        console.log("it's a draw");
        this.map[defenseX][defenseY] = 0;
        this.state[defenseX][defenseY] = EMPTY;
        this.map[attackX][attackY] = 0;
        this.state[attackX][attackY] = EMPTY;
      } else {
        console.log("player " + player + " loosed [" + x + ", " + y + "] field");
        this.map[attackX][attackY] = 0;
        this.state[attackX][attackY] = EMPTY;
        this.map[defenseX][defenseY] = defenseValue - attackValue;
        this.normalizeGroup(defenseX, defenseY);
      }
      return true;
    };

    KaluzaGame.prototype.obtainField = function(fieldX, fieldY, player) {
      this.state[fieldX][fieldY] = player;
      return this.normalizeGroup(fieldX, fieldY);
    };

    KaluzaGame.prototype.normalizeGroup = function(fieldX, fieldY) {
      var group, points, value, x, y, _i, _j, _len, _len1, _ref, _ref1, _results;
      group = this.getGroup(fieldX, fieldY);
      points = 0;
      for (_i = 0, _len = group.length; _i < _len; _i++) {
        _ref = group[_i], x = _ref[0], y = _ref[1];
        points += this.map[x][y];
      }
      value = Math.round(points / group.length);
      _results = [];
      for (_j = 0, _len1 = group.length; _j < _len1; _j++) {
        _ref1 = group[_j], x = _ref1[0], y = _ref1[1];
        _results.push(this.map[x][y] = value);
      }
      return _results;
    };

    KaluzaGame.prototype.isObtainable = function(x, y, player) {
      var nearX, nearY, _i, _len, _ref, _ref1;
      if (this.state[x][y] === player) {
        return true;
      }
      _ref = [[x - 1, y], [x + 1, y], [x, y - 1], [x, y + 1]];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        _ref1 = _ref[_i], nearX = _ref1[0], nearY = _ref1[1];
        if (nearX >= 0 && nearX < this.size && nearY >= 0 && nearY < this.size) {
          if (this.state[nearX][nearY] === player) {
            return true;
          }
        }
      }
      return false;
    };

    KaluzaGame.prototype.getFieldId = function(field) {
      var error, x, y;
      try {
        x = field[0], y = field[1];
        return "" + x + "-" + y;
      } catch (_error) {
        error = _error;
        return null;
      }
    };

    KaluzaGame.prototype.getGroup = function(startX, startY) {
      var fieldId, nearX, nearY, player, result, toVisit, visited, x, y, _i, _len, _ref, _ref1, _ref2;
      result = [];
      visited = [];
      toVisit = [[startX, startY]];
      player = this.state[startX][startY];
      while (toVisit.length > 0) {
        _ref = toVisit.pop(), x = _ref[0], y = _ref[1];
        result.push([x, y]);
        visited.push(this.getFieldId([x, y]));
        _ref1 = [[x - 1, y], [x + 1, y], [x, y - 1], [x, y + 1]];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          _ref2 = _ref1[_i], nearX = _ref2[0], nearY = _ref2[1];
          fieldId = this.getFieldId([nearX, nearY]);
          if (nearX >= 0 && nearX < this.size && nearY >= 0 && nearY < this.size) {
            if (this.state[nearX][nearY] === player && __indexOf.call(visited, fieldId) < 0) {
              toVisit.push([nearX, nearY]);
            }
          }
        }
      }
      return result;
    };

    KaluzaGame.prototype.chooseField = function() {
      var fieldX, fieldY, group, item, obtained, reachable_empty, reachable_opponent, sort_by_value, x, y, _i, _j, _k, _len, _ref, _ref1, _ref2, _ref3;
      reachable_empty = [];
      reachable_opponent = [];
      obtained = [];
      for (x = _i = 0, _ref = this.size - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; x = 0 <= _ref ? ++_i : --_i) {
        for (y = _j = 0, _ref1 = this.size - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; y = 0 <= _ref1 ? ++_j : --_j) {
          if (this.isObtainable(x, y, PLAYER_B)) {
            item = {
              field: [x, y],
              value: this.map[x][y]
            };
            if (this.state[x][y] === EMPTY) {
              reachable_empty.push(item);
            } else if (this.state[x][y] === PLAYER_A) {
              reachable_opponent.push(item);
            } else {
              obtained.push(item);
            }
          }
        }
      }
      sort_by_value = function(a, b) {
        return a.value - b.value;
      };
      obtained.sort(sort_by_value);
      obtained.reverse();
      reachable_empty.sort(sort_by_value);
      reachable_empty.reverse();
      reachable_opponent.sort(sort_by_value);
      if (reachable_empty.length > 0 && reachable_empty[0].value >= obtained[0].value) {
        return reachable_empty[0].field;
      }
      if (reachable_opponent.length > 0 && reachable_opponent[0].value < obtained[0].value) {
        return reachable_opponent[0].field;
      }
      if (obtained.length > 1) {
        _ref2 = shuffle(obtained);
        for (_k = 0, _len = _ref2.length; _k < _len; _k++) {
          item = _ref2[_k];
          _ref3 = item.field, fieldX = _ref3[0], fieldY = _ref3[1];
          group = this.getGroup(fieldX, fieldY);
          if (group.length > 0) {
            return item.field;
          }
        }
      }
      if (reachable_empty.length > 0) {
        return reachable_empty[0].field;
      }
      if (reachable_opponent.length > 0) {
        reachable_opponent.reverse();
        return reachable_opponent[0].field;
      }
      console.log('AI failed to choose field');
      return null;
    };

    KaluzaGame.prototype.finishTurn = function() {
      var x, y, _ref;
      _ref = this.hover[PLAYER_B], x = _ref[0], y = _ref[1];
      this.clickField(x, y, PLAYER_B, PLAYER_A);
      this.hover[PLAYER_B] = null;
      this.draw();
      return this.active_player = PLAYER_A;
    };

    KaluzaGame.prototype.opponentTurn = function() {
      var field;
      this.active_player = PLAYER_B;
      field = this.chooseField();
      if (field != null) {
        this.hover[PLAYER_B] = field;
        this.draw();
        setTimeout(this.finishTurn, 1000);
        return true;
      }
      this.active_player = PLAYER_A;
      return false;
    };

    return KaluzaGame;

  })();

  window.game = game = new KaluzaGame(4);

  window.onresize = function(event) {
    return game.refresh(event);
  };

  game.canvas.onclick = function(event) {
    return game.onClick(event);
  };

  game.canvas.onmousemove = function(event) {
    return game.onMouseMove(event);
  };

  game.canvas.onmouseout = function(event) {
    return game.onMouseOut(event);
  };

}).call(this);
